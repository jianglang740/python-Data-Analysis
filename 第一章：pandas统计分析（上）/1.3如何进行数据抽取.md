# 在进行数据分析时并不是所有的数据都是我们想要的，所以可以抽取部分数据来进行分析，主要使用DataFrame的loc属性和iloc属性

* loc属性，以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名index，即抽取整行数据，包括所有列，如df.loc['A']

* iloc属性，以行和列的位置索引即（0、1、2、3、、、）作为参数，当只有一个参数是默认是行索引，即抽取整行包括所有列，如df.iloc[0]
---
---
---
---




# Pandas `loc` vs `iloc` 超级详细教程

## 一、核心概念：位置索引 vs 标签索引

### 1. 位置索引（整数索引）
- **定义**：基于数据在DataFrame中的物理位置，从0开始计数
- **特点**：所有DataFrame都有位置索引，即使设置了自定义标签
- **示例**：在5行的DataFrame中，位置索引为0, 1, 2, 3, 4

### 2. 标签索引（行名/列名）
- **定义**：DataFrame中每行和每列的标识符
- **特点**：
  - 行标签：通过`df.index`访问（默认是RangeIndex: 0,1,2...）
  - 列标签：通过`df.columns`访问
- **示例**：自定义行标签为学号('001','002'...)，列标签为['姓名', '年龄', '成绩']


## 二、示例DataFrame：学生成绩表

我们使用以下DataFrame进行演示：

```python
import pandas as pd

data = {
    '姓名': ['张三', '李四', '王五', '赵六', '钱七'],
    '年龄': [18, 19, 18, 20, 19],
    '性别': ['男', '女', '男', '女', '男'],
    '数学': [95, 87, 92, 89, 91],
    '语文': [88, 91, 85, 93, 87],
    '英语': [92, 89, 94, 90, 88]
}

# 创建DataFrame并设置学号为行标签
df = pd.DataFrame(data, index=['001', '002', '003', '004', '005'])
print(df)
```

**输出结果：**

|      | 姓名   | 年龄 | 性别 | 数学 | 语文 | 英语 |
|------|--------|------|------|------|------|------|
| 001  | 张三   | 18   | 男   | 95   | 88   | 92   |
| 002  | 李四   | 19   | 女   | 87   | 91   | 89   |
| 003  | 王五   | 18   | 男   | 92   | 85   | 94   |
| 004  | 赵六   | 20   | 女   | 89   | 93   | 90   |
| 005  | 钱七   | 19   | 男   | 91   | 87   | 88   |

**索引结构分析：**
- **行标签（索引）**：`['001', '002', '003', '004', '005']`
- **列标签**：`['姓名', '年龄', '性别', '数学', '语文', '英语']`
- **位置索引**：
  - 行位置：0, 1, 2, 3, 4
  - 列位置：0, 1, 2, 3, 4, 5


## 三、`loc` 深度解析：基于标签的索引

### 1. 基本语法
```python
df.loc[row_label, column_label]
```
- `row_label`：行标签（单个标签、标签列表、标签切片或布尔数组）
- `column_label`：列标签（同上）


### 2. 单行选择
**示例1**：选择学号为'003'的学生信息
```python
print(df.loc['003'])
```

**输出**：
```
姓名    王五
年龄    18
性别     男
数学    92
语文    85
英语    94
Name: 003, dtype: object
```

**关键细节**：
- 返回一个Series，索引为列标签
- 如果标签不存在，会抛出`KeyError`


### 3. 多行选择
**示例2**：选择学号从'002'到'004'的学生
```python
print(df.loc['002':'004'])
```

**输出**：
|      | 姓名   | 年龄 | 性别 | 数学 | 语文 | 英语 |
|------|--------|------|------|------|------|------|
| 002  | 李四   | 19   | 女   | 87   | 91   | 89   |
| 003  | 王五   | 18   | 男   | 92   | 85   | 94   |
| 004  | 赵六   | 20   | 女   | 89   | 93   | 90   |

**关键细节**：
- **闭区间**：包含起始和结束标签（与Python切片不同）
- 标签顺序必须与索引顺序一致（否则返回空DataFrame）


### 4. 行和列同时选择
**示例3**：选择学号'002'到'004'的学生的姓名、数学和英语成绩
```python
print(df.loc['002':'004', ['姓名', '数学', '英语']])
```

**输出**：
|      | 姓名   | 数学 | 英语 |
|------|--------|------|------|
| 002  | 李四   | 87   | 89   |
| 003  | 王五   | 92   | 94   |
| 004  | 赵六   | 89   | 90   |


### 5. 布尔索引
**示例4**：选择年龄大于19岁的学生的所有信息
```python
print(df.loc[df['年龄'] > 19])
```

**输出**：
|      | 姓名   | 年龄 | 性别 | 数学 | 语文 | 英语 |
|------|--------|------|------|------|------|------|
| 004  | 赵六   | 20   | 女   | 89   | 93   | 90   |

**布尔索引原理**：
1. `df['年龄'] > 19` 返回布尔Series：
   ```
   001    False
   002    False
   003    False
   004     True
   005    False
   Name: 年龄, dtype: bool
   ```
2. `loc` 根据布尔值选择对应行


### 6. 可调用对象索引
**示例5**：选择数学成绩高于平均分的学生
```python
print(df.loc[lambda x: x['数学'] > x['数学'].mean()])
```

**输出**：
|      | 姓名   | 年龄 | 性别 | 数学 | 语文 | 英语 |
|------|--------|------|------|------|------|------|
| 001  | 张三   | 18   | 男   | 95   | 88   | 92   |
| 003  | 王五   | 18   | 男   | 92   | 85   | 94   |
| 005  | 钱七   | 19   | 男   | 91   | 87   | 88   |


### 7. 赋值操作
**示例6**：将学号为'001'的学生的数学成绩改为98
```python
df.loc['001', '数学'] = 98
```

**示例7**：将所有男生的英语成绩加5分
```python
df.loc[df['性别'] == '男', '英语'] += 5
```


## 四、`iloc` 深度解析：基于位置的索引

### 1. 基本语法
```python
df.iloc[row_position, column_position]
```
- `row_position`：行位置（单个整数、整数列表、整数切片）
- `column_position`：列位置（同上）


### 2. 单行选择
**示例1**：选择第三行（索引为2）的学生信息
```python
print(df.iloc[2])
```

**输出**：
```
姓名    王五
年龄    18
性别     男
数学    92
语文    85
英语    94
Name: 003, dtype: object
```


### 3. 多行选择
**示例2**：选择第二行到第四行（索引1到3）的学生
```python
print(df.iloc[1:4])
```

**输出**：
|      | 姓名   | 年龄 | 性别 | 数学 | 语文 | 英语 |
|------|--------|------|------|------|------|------|
| 002  | 李四   | 19   | 女   | 87   | 91   | 89   |
| 003  | 王五   | 18   | 男   | 92   | 85   | 94   |
| 004  | 赵六   | 20   | 女   | 89   | 93   | 90   |

**关键细节**：
- **半开区间**：包含起始位置，不包含结束位置（与Python切片一致）


### 4. 行和列同时选择
**示例3**：选择第二行到第四行（索引1到3）的学生的第一列（姓名）、第四列（数学）和第六列（英语）
```python
print(df.iloc[1:4, [0, 3, 5]])
```

**输出**：
|      | 姓名   | 数学 | 英语 |
|------|--------|------|------|
| 002  | 李四   | 87   | 89   |
| 003  | 王五   | 92   | 94   |
| 004  | 赵六   | 89   | 90   |


### 5. 切片与步长
**示例4**：选择所有奇数行（索引0, 2, 4）
```python
print(df.iloc[::2])
```

**输出**：
|      | 姓名   | 年龄 | 性别 | 数学 | 语文 | 英语 |
|------|--------|------|------|------|------|------|
| 001  | 张三   | 18   | 男   | 95   | 88   | 92   |
| 003  | 王五   | 18   | 男   | 92   | 85   | 94   |
| 005  | 钱七   | 19   | 男   | 91   | 87   | 88   |


### 6. 赋值操作
**示例5**：将第二行（索引1）的学生的英语成绩改为95
```python
df.iloc[1, 5] = 95
```

**示例6**：将最后两行的数学成绩都改为100
```python
df.iloc[-2:, 3] = 100
```


## 五、高级技巧与常见问题

### 1. 获取列的位置索引
如果你知道列标签，但需要使用`iloc`，可以通过`df.columns.get_loc()`获取列位置：

**示例**：选择'数学'列（位置索引为3）
```python
math_col_idx = df.columns.get_loc('数学')
print(df.iloc[:, math_col_idx])
```


### 2. 标签与位置的混合使用
**错误示例**：
```python
df.iloc['001', '数学']  # 错误：iloc只能接受整数位置
```

**正确方法**：
```python
# 方法1：先转换标签为位置
row_idx = df.index.get_loc('001')
col_idx = df.columns.get_loc('数学')
print(df.iloc[row_idx, col_idx])

# 方法2：直接使用loc
print(df.loc['001', '数学'])
```


### 3. 当索引是整数时的混淆
如果DataFrame使用整数作为标签索引（如`index=[10, 20, 30]`）：
- `loc[20]`：选择标签为20的行
- `iloc[20]`：选择位置索引为20的行（如果存在）

**示例**：
```python
df2 = pd.DataFrame({'A': [1, 2, 3]}, index=[10, 20, 30])
print(df2.loc[20])  # 选择标签为20的行（第二行）
print(df2.iloc[1])  # 选择位置索引为1的行（第二行）
```


### 4. 避免链式索引（Chained Indexing）
**错误示例**：
```python
df[df['性别'] == '男']['数学'] = 100  # 链式索引，可能不修改原数据
```

**正确示例**：
```python
df.loc[df['性别'] == '男', '数学'] = 100  # 单步索引，确保修改原数据
```


## 六、性能考虑

### 1. 直接索引 vs loc/iloc
- **直接索引**：`df[col_label]` 或 `df[col_list]`
  - 只能选择列，不能同时选择行
  - 示例：`df['数学']` 或 `df[['数学', '语文']]`

- **loc/iloc**：
  - 可以同时选择行和列
  - 性能稍慢，但更安全（避免链式索引）

### 2. 大数据集的性能
对于非常大的DataFrame（百万行以上），`iloc` 通常比 `loc` 快约10-20%，因为整数索引查找更快。


## 七、总结表格

| **场景**                     | **loc**                          | **iloc**                         |
|------------------------------|----------------------------------|----------------------------------|
| 索引类型                     | 标签（行名和列名）               | 整数位置（从0开始）              |
| 区间行为                     | 闭区间（包含起止）               | 半开区间（包含起始，不包含结束） |
| 单行选择                     | `df.loc['003']`                  | `df.iloc[2]`                     |
| 多行选择                     | `df.loc['002':'004']`            | `df.iloc[1:4]`                   |
| 行列同时选择                 | `df.loc[rows, cols]`             | `df.iloc[row_idxs, col_idxs]`    |
| 布尔索引                     | `df.loc[df['年龄'] > 19]`        | 需先转换为位置索引               |
| 获取单个值                   | `df.loc['001', '数学']`          | `df.iloc[0, 3]`                  |
| 当索引为整数时               | 按标签选择                       | 按位置选择                       |


## 八、练习题

1. 从示例DataFrame中选择所有女生的信息
2. 选择数学成绩最高的学生的姓名和英语成绩
3. 将年龄小于20岁的学生的语文成绩加5分
4. 选择前三行的姓名、性别和英语成绩（分别用loc和iloc实现）
5. 创建一个新列'总分'，计算每个学生的三科总分

**答案见下方（先尝试自己解决）**


## 九、练习题答案

1. **选择所有女生的信息**
   ```python
   print(df.loc[df['性别'] == '女'])
   ```

2. **选择数学成绩最高的学生的姓名和英语成绩**
   ```python
   max_math_idx = df['数学'].idxmax()
   print(df.loc[max_math_idx, ['姓名', '英语']])
   ```

3. **将年龄小于20岁的学生的语文成绩加5分**
   ```python
   df.loc[df['年龄'] < 20, '语文'] += 5
   ```

4. **选择前三行的姓名、性别和英语成绩**
   ```python
   # 使用loc
   print(df.loc[['001', '002', '003'], ['姓名', '性别', '英语']])
   
   # 使用iloc
   print(df.iloc[:3, [0, 2, 5]])
   ```

5. **创建总分列**
   ```python
   df['总分'] = df['数学'] + df['语文'] + df['英语']
   ```

